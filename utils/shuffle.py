# Reading material at voting17_HLKD17.pdf

# libraries:
# Verificatum Mix-Net
# UniCrypt library
import random
import utils.generators as gen

# Generates a random permutation ψ ∈ ΨN following Knuth’s shuffle algorithm.
def GenPermutation(N):
    I = list(range(N))
    j_i = list(range(N))
    for i in range(N):
        k = random.randint(i, N-1)
        j_i[i] = I[k]
        I[k] = I[i]
    return j_i

# Generates a random permutation ψ ∈ Ψ_N and use it to shuffle a
# given list e of pk_i into a shuffled list e′.
def GenShuffle(e, pk):
    N = len(e)
    ψ = GenPermutation(N)
    _, _, order = gen.pp
    
    r_prime = []
    e_prime = []

    for i in range(N):
        r_i = order.random()
        r_prime.append(r_i)
        
        pk = e[i]
        # pk_prime = pk * pow(g, r_i)
        pk_prime = pk * r_i # make sure the elliptic curve calculation conversion is correct
        
        e_prime.append(pk_prime)

    # shuffle it
    e_prime_shuffled = [e_prime[ψ[j]] for j in range(N)]
    return (e_prime_shuffled, r_prime, ψ)


# Algorithm 4.4: Generates a commitment c = Com(ψ, r) to a permutation ψ by
# committing to the columns of the corresponding permutation matrix.
# Algorithm: GenCommitment(ψ)
# Input: Permutation ψ = (j1, ... , jN ) ∈ Ψ_N
# for i = 1, ... , N do
# r_j_i ∈R Z_q
# c_j_i ← g^r_j_i h_i mod p
# c ← (c_1, ... , c_N )
# r ← (r_1, ... , r_N )
# return (c, r)
def GenCommitment(ψ):
    _, g, order = gen.pp
    N = len(ψ)
    c = []
    r = []

    group = gen.pp[0] # gets the group
    h = group.hash_to_point(b"h generator label") # creates h, which is a fixed label. (uses petlib's hash_to_point)
    # h is being hashed to a point on the curve. This is unrelated to g, so an attacker cannot (easily) find a relation between g and h.

    for i in range(N):
        r_j_i = order.random()
        r.append(r_j_i) # randomness for each commitment

        #From g^r * h since we are using ecc and that makes the group additive, 
        # so ^ becomes *,  * becomes + and mod p is handled by the curve
        c_j_i = g.pt_mul(r_j_i) + h.pt_mul(ψ[i]) # commitments
        c.append(c_j_i)

    return (c, r)

def testCommitment():
    N = 4
    ψ = GenPermutation(N)
    print("permutations ", ψ)
    c, r = GenCommitment(ψ)
    print("the commits ", c)
    for index, c in enumerate(c):
        print(f"c[{index}] = {c}")
    print("the randomness ", r)

testCommitment()

# Algorithm 4.5: Generates a commitment chain c0 → c1 → · · · → cN relative to a
# list of public challenges u and starting with a given commitment c0
def GenCommitmentChain(c0, u):
    return ""

# Algorithm 4.3: Generates a proof of shuffle for given ElGamal encryptions e and
# e′ according to Wikström’s method
# GenProof(e, e′, r′, ψ, pk
# Input:
# ElGamal encryptions e = (e1, ... , eN ), e_i = (ai, bi) ∈ G^2_q
# Shuffled ElGamal encryptions e′ = (e′ 1, ... , e′ N ), e′ i = (a′ i, b′ i) ∈ ^2_q
# Re-encryption randomizations r′ = (r′ 1, ... , r′ N ), r′ i ∈ _q
# Permutation ψ = (j1, ... , jN ) ∈ Ψ_N
# Encryption key pk ∈ G

# TODO unfinished
def GenProof(e, e_prime, r_prime, ψ, pk):
    _, g, order = gen.pp
    N = len(e)
    q = order.n

    c, r = GenCommitment(ψ)

    u = []
    u_prime = []

    for i in range(N):
        u_i = hash((e, e_prime, c), i)
        u.append(u_i)
        u_prime.append(u[ψ[i]])

    

# Algorithm 4.6: Checks the correctness of a shuffle proof π generated by Algo-
# rithm 4.3. The public values are the ElGamal encryptions e and e′ and the public
# encryption key pk.
def CheckProof():
    return ""
