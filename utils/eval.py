from utils.dec_proof import hash_to_bn
from utils.procedures import Procedures
import threshold_crypto as tc

#####
# Eval() outputs an evaluation and showcases which users have met the target reduction
# example:
# M_set = [1,0,1,1,0] means that user 0,2,3 have met the target reduction
# user 1 and 4 have not met the target reduction

# enc               returns [(c1, c2), ...]     a list of tuples
# ct_aggregation    returns (c1,c2)             a tuple
# ct_reduction
#   ct_b            comes from enc
#   ct_m            comes from enc
# epet
# ct_sum comes from ct_aggregation and                  its a tuple
# ct_t comes from dso target list generated by enc      its a list
# epet runs sub, crashes because minus list and

def sub(c1, c2):
    """
    Computes Enc(m1 - m2) given Enc(m1) and Enc(m2)
    Inputs are Lists [(C1, C2)]. Output is List [(C1, C2)]
    """
    # print("\nc1: \n" + str(c1))
    # print("\nc2: \n" + str(c2))

    a1, b1 = c1[0] # baseline from smartmeters      ||| small number
    a2, b2 = c2[0] # consumption from smartmeters   ||| big number
    
    return [(a1 + (-a2), b1 + (-b2))]

#=============
# Eval(BB, PBB, dk_share, agg_id, dso_ek) → (PBB, BB)
# with threshold decryption
#=============

# takes dk_share and agg_id instead of full dk
# Takes this aggregator's 'dk_share' and 'agg_id'
def eval(BB, PBB, dk_share, dso_ek, agg_id):
    """
    Retrieves reports, computes individual reductions, aggregates them, 
    and initiates the threshold decryption process to verify targets
    """
    # list of cts
    # ct_b: baseline ciphertexts from BB
    ct_b = getattr(BB, "ct_b", None)
    if ct_b is None:
        print("Public board missing baseline ciphertexts (ct_b).")
        return (PBB, BB)
    
    ct_b_single = None
    
    if isinstance(ct_b, tuple):
        noisy_list = ct_b[0] 
        ct_b_single = noisy_list[0] 
    elif isinstance(ct_b, list):
        ct_b_single = ct_b[0]
    else:
        ct_b_single = ct_b

    # ct_t: consumption reports from PBB
    consumption_reports = getattr(PBB, "ct_t", None)
    if consumption_reports is None:
        print("Private board missing consumption reports (ct_t).")
        return (PBB, BB)

    try:
        ct_T = BB.get_target_reduction()
        # print("\n----> ct_T :" + str(ct_T) + "")
    except AttributeError:
        print("No ct_T found in BB during Eval")
        return (PBB, BB)
    
    # lists
    eval_results_step1 = [] 
    CT_red = [] 

    # Steps 1, 2, 3: Loop and call placeholders
    for pk_prime, report_data in consumption_reports.items():
        t = report_data[0]
        ct_m = report_data[1] 

        # step 1:ord comparison
        ct_o, ord_proof = ord_comparison(ct_b, ct_m)
        eval_results_step1.append((ct_o, t, pk_prime, ord_proof))

        # step 2 ct reduction
        ct_red = ct_reduction(ct_b_single, ct_m, ct_o) 

        # step 3 set CT_red
        CT_red.append((ct_red, t, pk_prime))

    # step 4: Aggregation
    ct_sum = ct_aggregation(CT_red)
    BB.ct_sum = ct_sum

    # STEP 5: PET COMPARISON
    # Check if ct_eq already exists on the board.
    # If it does, we'll use the existing one so all aggregators 
    # decrypt the same ciphertext.
    
    existing_ct_eq = getattr(BB, "ct_eq", None)
    
    if existing_ct_eq is not None:
        print(f"Aggregator {agg_id} using existing ct_eq from Public Board.")
        ct_eq = existing_ct_eq
        # verify BB.π_eq here normally
        π_eq = getattr(BB, "π_eq", None)

        if π_eq is None or len(π_eq) != len(ct_eq):
            print("Error: Missing proofs on board.")
            return (PBB, BB)

        # VERIFY THE PROOFS
        # We check that ct_eq correctly represents (ct_sum - ct_T)^r
        all_valid = True
        for i in range(len(ct_eq)):
            # verify_r(ct_sum, ct_target, ct_result, proof, pub_key)
            if not verify_r(ct_sum, ct_T[i], ct_eq[i], π_eq[i], dso_ek):
                print(f"Verification failed for target {i}")
                all_valid = False
                break
        
        if not all_valid:
            print(f"Aggregator {agg_id} rejected the calculation.")
            return (PBB, BB)
            
        print(f"Aggregator {agg_id} successfully verified all PET proofs.")

    else:
        print(f"Aggregator {agg_id} computing new PET (ct_eq) and publishing to Board.")
        ct_eq, π_eq = pet_comparison(ct_sum, ct_T, dso_ek)
        
        # Publish immediately so the next aggregator uses this one
        BB.ct_eq = ct_eq
        BB.π_eq = π_eq
        BB.eval_results = eval_results_step1 

    # STEP 6: PARTIAL DECRYPTION
    # Call partial_decrypt with agg's share
    M_shares_list, π_dec_share = partial_decrypt(ct_eq, dk_share)
    
    #####
    # Update the boards with eval results
    
    # Store the aggregators partial share on the board
    if not hasattr(BB, "M_shares"):
        BB.M_shares = {}
    if not hasattr(BB, "pi_dec_shares"):
        BB.pi_dec_shares = {}

    # Publish the agg's share, labeled by its ID
    BB.M_shares[agg_id] = M_shares_list
    BB.pi_dec_shares[agg_id] = π_dec_share
    
    BB.eval_status = "evaluated_partial_decryption"

    # private board
    PBB.eval_data = {
        "ct_b": ct_b,
        "consumption_reports": consumption_reports,
        "dk_share": "hidden" 
    }
    
    return (PBB, BB)

# (cto, t, pk′, π_ord) ← ord(ctb, ctm)
def ord_comparison(ct_b, ct_c):
    """
    Order Comparison of two ciphertexts.
    [Intended] Should return Enc(1) if Consumption < Baseline, else Enc(0).
    Requires NIZKP.
    
    """
    pro = Procedures()
    pp = pro.pub_param()
    g = pp[1]
    # identity_point = 0 * g
    # ct_o = (identity_point, identity_point)

    # placeholder
    c1 = 0 * g # identity
    c2 = 1 * g

    ct_o = (c1, c2) # should be decrypted

    ord_proof = "ord_proof not implemented" # placeholder
    return ct_o, ord_proof

# ctred ← Reduct(ct_b, c_tm, ct_o)
def ct_reduction(ct_b, ct_m, ct_o):
    """
    (for step 2) Conditional Reduction Calculation.
    [Intended] Should compute Enc((Baseline - Consumption) * ct_o).
    Requires homomorphic multiplication to apply the condition.
    [Current] Placeholder: Returns Enc(0) (Identity point).
    Does not perform subtraction; assumes 0 reduction.
    """
    # baselilne - measured
    ct_diff = sub(ct_b, ct_m)

    return ct_diff
    # pro = Procedures()
    # pp = pro.pub_param()
    # g = pp[1]
    # identity_point = 0 * g
    # ct_red = (identity_point, identity_point)
    # return ct_red

# ctsum ← Agg(ct_red)
def ct_aggregation(reduc_set):
    """
    (for step 4) Homomorphic Aggregation.
    Sums all individual reductions into a single ciphertext (ct_sum).
    Uses the additive homomorphic property (for Ec).
    """
    C1_prod, C2_prod = reduc_set[0][0][0] 
    
    for i in range(1, len(reduc_set)):
        C1_i, C2_i = reduc_set[i][0][0]
        
        C1_prod = C1_prod + C1_i
        C2_prod = C2_prod + C2_i
        
    return [(C1_prod, C2_prod)]

# (cteq, πeq ) ← Pet(ctsum, ctT )
def pet_comparison(ct_sum, ct_T, dso_ek):
    """
    (for step 5) Private Equality Test
    Iterates through targets (ct_T) to compare against ct_sum (to verify reductions).
    Calls epet for each target.
    """
    ct_eq = []
    π_eq = []
    # print("pet_comparison -> ct_T: " + str(ct_T))
    for ct_T_i in ct_T:
        ct_eq_i, π_r_i = epet(ct_sum, ct_T_i, dso_ek)
        ct_eq.append(ct_eq_i)
        π_eq.append(π_r_i)

    return (ct_eq, π_eq)

# (ct_eq_i, π_r_i) ← Epet(ct_sum, ct_T_i)
def epet(ct_sum, ct_t_i, dso_ek):
    """
    Encrypted Private Equality Test (EPET) (page 19 in given report)
    Computes Enc(r * (Sum - Target)).
    If Sum == Target, result is Enc(0). If not, result is Enc(Random).
    Includes generation of proof 'r'.
    This uses the non-interactive zero-knowledge proof (NIZKP) proof_r
    """
    pro = Procedures()
    pp = pro.pub_param()
    g = pp[1]
    order = pp[2]
    
    r = tc.number.random_in_range(1, order)

    # ct_diff is a list
    ct_diff = sub(ct_sum, ct_t_i)
    (C1_diff, C2_diff) = ct_diff[0]

    C1_eq = int(r) * C1_diff
    C2_eq = int(r) * C2_diff

    # ct_eq is a tuple (not a list)
    ct_eq = (C1_eq, C2_eq)

    # pass the lists ct_sum and ct_t_i to proof_r
    π_r_i = proof_r(ct_sum, ct_t_i, ct_eq, r, dso_ek)

    return (ct_eq, π_r_i)

def proof_r(ct1, ct2, ct_eq, r, dso_ek):
    """
    NIZKP for r used in EPET.
    ct1: ct_sum (List)
    ct2: ct_target (List)
    ct_eq: Tuple (C1, C2)
    """
    pro = Procedures()
    pp = pro.pub_param()
    g = pp[1]
    order = pp[2]

    # lists, [(C1, C2)]
    C1_1, C2_1 = ct1[0]
    C1_2, C2_2 = ct2[0]

    C1_eq, C2_eq = ct_eq

    # lists [(C1, C2)]
    ct_diff = sub(ct1, ct2)
    C1_diff, C2_diff = ct_diff[0]

    s = tc.number.random_in_range(1, order)  # nonce

    A1 = int(s) * C1_diff
    A2 = int(s) * C2_diff

    challenge = hash_to_bn(g, dso_ek, C1_1, C1_2, C2_1, C2_2, C1_eq, C2_eq, A1, A2, order=order)

    response = (int(s) + int(challenge) * int(r)) % int(order)

    return (A1, A2, response, challenge)

def verify_r(ct1, ct2, ct_eq, proof, dso_ek):
    """
    Verifies the NIZKP Proof for r
    """
    pro = Procedures()
    pp = pro.pub_param()
    g = pp[1]
    order = pp[2]

    A1, A2, response, challenge = proof

    # lists, [(C1, C2)]
    C1_1, C2_1 = ct1[0]
    C1_2, C2_2 = ct2[0]

    C1_eq, C2_eq = ct_eq

    # lists, [(C1, C2)]
    ct_diff = sub(ct1, ct2)
    C1_diff, C2_diff = ct_diff[0]

    c_check = hash_to_bn(g, dso_ek, C1_1, C1_2, C2_1, C2_2, C1_eq, C2_eq, A1, A2, order=order)

    V1 = int(response) * C1_diff
    V2 = int(response) * C2_diff

    check1 = (V1 == A1 + (int(challenge) * C1_eq))
    check2 = (V2 == A2 + (int(challenge) * C2_eq))

    return check1 and check2 and (int(challenge) == int(c_check))

# Renamed from prove_epet_computation to partial_decrypt
# ({M_share}, π_dec_share) ← PDec_Partial(ct_eq, dk_share)
def partial_decrypt(ct_eq, dk_share):
    """
    Performs partial decryption on a list of ciphertexts using
    this aggregator's secret key share.
    Returns: (M_shares_list, pi_dec_proofs)
    """
    pro = Procedures()
    
    # Use the ElGamal partial_decrypt method
    M_shares_list = pro.ahe.partial_decrypt(ct_eq, dk_share)
    
    # Placeholder proofs - in production, generate actual NIZKP
    pi_dec_proofs = ["placeholder_proof_of_decryption_share"] * len(ct_eq)

    return (M_shares_list, pi_dec_proofs)

def combine_decryption_shares(BB, thresh_params):
    """Combine threshold decryption shares from multiple aggregators."""
    print("Attempting to combine decryption shares...")

    try:
        share_lists = list(BB.M_shares.values())
        if not share_lists:
            print("No decryption shares found on board.")
            return

        ct_eq_list = BB.ct_eq
        
        pro = Procedures()
        pp = pro.pub_param()
        g = pp[1]
        
        # Define Identity Point (0*G)
        identity_point = 0 * g
        
        M_set_final = []
        num_aggs = len(share_lists)

        for i in range(len(ct_eq_list)):
            # Get partial decryptions for ciphertext i from all aggregators
            partials_for_ct_i = [share_lists[agg_idx][i] for agg_idx in range(num_aggs)]
            
            # using point decryption, not int
            plaintext_point = pro.ahe.threshold_decrypt_point(
                partials_for_ct_i,
                ct_eq_list[i],  # Pass tuple (C1, C2) directly
                thresh_params
            )

            # Check if result is Identity (Target met) or Random (Target not met)
            if plaintext_point == identity_point:
                M_set_final.append(1)  # Target met (Diff == 0)
            else:
                M_set_final.append(0)  # Target not met (Diff != 0)
        
        BB.M_set = M_set_final
        BB.eval_status = "evaluated_complete"
        print(f"Share combination complete. Final M_set: {BB.M_set}")

    except Exception as e:
        print(f"Error combining shares: {e}")
        BB.eval_status = "evaluation_failed_combination"


# def test_sub():
#     """Test the subtraction of two ciphertexts."""
#     print("=== Testing sub() ===")
    
#     pro = Procedures()
#     pp = pro.pub_param()
#     curve = pp[0]
#     g = pp[1]
#     order = pp[2]
    
#     # Create two simple ciphertexts
#     r1 = tc.number.random_in_range(1, order)
#     r2 = tc.number.random_in_range(1, order)
    
#     c1 = (int(r1) * g, int(r1) * g)
#     c2 = (int(r2) * g, int(r2) * g)
    
#     result = sub(c1, c2)
#     print(f"Subtraction successful: {result}")
    
#     # Verify result structure
#     assert isinstance(result, tuple) and len(result) == 2
#     print("✓ sub() test passed\n")


# def test_ord_comparison():
#     """Test order comparison placeholder."""
#     print("=== Testing ord_comparison() ===")
    
#     pro = Procedures()
#     pp = pro.pub_param()
#     g = pp[1]
#     identity = 0 * g
    
#     ct_b = (identity, identity)
#     ct_m = (identity, identity)
    
#     ct_o, proof = ord_comparison(ct_b, ct_m)
#     print(f"ord_comparison returned: ct_o={ct_o}, proof={proof}")
    
#     assert ct_o == (identity, identity)
#     print("✓ ord_comparison() test passed\n")


# def test_ct_reduction():
#     """Test ciphertext reduction placeholder."""
#     print("=== Testing ct_reduction() ===")
    
#     pro = Procedures()
#     pp = pro.pub_param()
#     g = pp[1]
#     identity = 0 * g
    
#     ct_b = (identity, identity)
#     ct_m = (identity, identity)
#     ct_o = (identity, identity)
    
#     ct_red = ct_reduction(ct_b, ct_m, ct_o)
#     print(f"ct_reduction returned: {ct_red}")
    
#     assert ct_red == (identity, identity)
#     print("✓ ct_reduction() test passed\n")


# def test_ct_aggregation():
#     """Test homomorphic aggregation of ciphertexts."""
#     print("=== Testing ct_aggregation() ===")
    
#     pro = Procedures()
#     pp = pro.pub_param()
#     g = pp[1]
#     order = pp[2]
    
#     # Create some reduction ciphertexts
#     reduc_set = []
#     for i in range(3):
#         r = tc.number.random_in_range(1, order)
#         ct_red = (int(r) * g, int(r) * g)
#         reduc_set.append((ct_red, i, f"pk_prime_{i}"))
    
#     ct_sum = ct_aggregation(reduc_set)
#     print(f"Aggregated ciphertext: {ct_sum}")
    
#     assert isinstance(ct_sum, tuple) and len(ct_sum) == 2
#     print("✓ ct_aggregation() test passed\n")


# def test_epet_and_proofs():
#     """Test EPET with proof generation and verification."""
#     print("=== Testing epet(), proof_r(), and verify_r() ===")
    
#     pro = Procedures()
#     pp = pro.pub_param()
#     curve = pp[0]
#     g = pp[1]
#     order = pp[2]
    
#     # Generate encryption key
#     sk = tc.number.random_in_range(1, order)
#     ek = int(sk) * g
    
#     # Create ct_sum (encrypted value)
#     ahe = pro.ahe
#     msg1 = 5
#     ct_sum = ahe.enc(ek, msg1)[0]  # Take first ciphertext
    
#     # Create ct_T (target - same value, should result in Enc(0))
#     msg2 = 5
#     ct_T_same = ahe.enc(ek, msg2)[0]
    
#     # Create ct_T (different value, should result in Enc(random))
#     msg3 = 7
#     ct_T_diff = ahe.enc(ek, msg3)[0]
    
#     print("\n--- Test 1: Same values (should produce Enc(0)) ---")
#     ct_eq_same, proof_same = epet(ct_sum, [ct_T_same], ek)
#     print(f"Generated ct_eq and proof")
    
#     # Verify the proof
#     is_valid_same = verify_r(ct_sum, [ct_T_same], ct_eq_same, proof_same, ek)
#     print(f"Proof verification (same values): {is_valid_same}")
#     assert is_valid_same, "Proof verification failed for same values!"
    
#     print("\n--- Test 2: Different values (should produce Enc(random)) ---")
#     ct_eq_diff, proof_diff = epet(ct_sum, [ct_T_diff], ek)
#     print(f"Generated ct_eq and proof")
    
#     # Verify the proof
#     is_valid_diff = verify_r(ct_sum, [ct_T_diff], ct_eq_diff, proof_diff, ek)
#     print(f"Proof verification (different values): {is_valid_diff}")
#     assert is_valid_diff, "Proof verification failed for different values!"
    
#     print("\n--- Test 3: Tampered proof (should fail) ---")
#     A1, A2, response, challenge = proof_diff
#     tampered_proof = (A1, A2, response + 1, challenge)  # Tamper with response
#     is_valid_tampered = verify_r(ct_sum, [ct_T_diff], ct_eq_diff, tampered_proof, ek)
#     print(f"Proof verification (tampered): {is_valid_tampered}")
#     assert not is_valid_tampered, "Tampered proof should not verify!"
    
#     print("✓ EPET and proof tests passed\n")


# def test_pet_comparison():
#     """Test PET comparison with multiple targets."""
#     print("=== Testing pet_comparison() ===")
    
#     pro = Procedures()
#     pp = pro.pub_param()
#     g = pp[1]
#     order = pp[2]
    
#     # Generate encryption key
#     sk = tc.number.random_in_range(1, order)
#     ek = int(sk) * g
    
#     # Create ct_sum
#     ahe = pro.ahe
#     msg_sum = 10
#     ct_sum = ahe.enc(ek, msg_sum)[0]
    
#     # Create multiple targets
#     ct_T = []
#     for target_val in [5, 10, 15]:
#         ct_target = ahe.enc(ek, target_val)
#         ct_T.append(ct_target)
    
#     ct_eq, π_eq = pet_comparison(ct_sum, ct_T, ek)
    
#     print(f"Generated {len(ct_eq)} equality ciphertexts")
#     print(f"Generated {len(π_eq)} proofs")
    
#     assert len(ct_eq) == 3
#     assert len(π_eq) == 3
    
#     # Verify all proofs
#     for i in range(len(ct_eq)):
#         is_valid = verify_r(ct_sum, ct_T[i], ct_eq[i], π_eq[i], ek)
#         print(f"Target {i} proof valid: {is_valid}")
#         assert is_valid, f"Proof {i} verification failed!"
    
#     print("✓ pet_comparison() test passed\n")


# def test_partial_decrypt():
#     """Test partial decryption with key shares."""
#     print("=== Testing partial_decrypt() ===")
    
#     pro = Procedures()
#     pp = pro.pub_param()
    
#     # Generate threshold keys
#     ek, key_shares, thresh_params = pro.ahe.keygen_threshold(pp)
    
#     # Encrypt some values
#     ct_eq = []
#     for val in [0, 5, 10]:
#         cts = pro.ahe.enc(ek, val)
#         ct_eq.append(cts[0])  # Take first ciphertext of each
    
#     # Get partial decryption from first key share
#     M_shares, proofs = partial_decrypt(ct_eq, key_shares[0])
    
#     print(f"Generated {len(M_shares)} partial decryptions")
#     print(f"Generated {len(proofs)} proofs")
    
#     assert len(M_shares) == 3
#     assert len(proofs) == 3
    
#     print("✓ partial_decrypt() test passed\n")


# def test_combine_decryption_shares():
#     """Test combining partial decryption shares."""
#     print("=== Testing combine_decryption_shares() ===")
    
#     # Create mock board
#     class MockBoard:
#         pass
    
#     BB = MockBoard()
    
#     pro = Procedures()
#     pp = pro.pub_param()
    
#     # Generate threshold keys (2-of-2)
#     ek, key_shares, thresh_params = pro.ahe.keygen_threshold(pp)
    
#     # Encrypt test values
#     test_values = [0, 5, 10]
#     ct_eq = []
#     for val in test_values:
#         cts = pro.ahe.enc(ek, val)
#         ct_eq.append(cts[0])
    
#     BB.ct_eq = ct_eq
    
#     # Get partial decryptions from both aggregators
#     M_shares_agg1, _ = partial_decrypt(ct_eq, key_shares[0])
#     M_shares_agg2, _ = partial_decrypt(ct_eq, key_shares[1])
    
#     BB.M_shares = {
#         "agg1": M_shares_agg1,
#         "agg2": M_shares_agg2
#     }
    
#     # Combine shares
#     combine_decryption_shares(BB, thresh_params)
    
#     print(f"Final M_set: {BB.M_set}")
#     print(f"Eval status: {BB.eval_status}")
    
#     assert hasattr(BB, "M_set")
#     assert BB.eval_status == "evaluated_complete"
#     assert len(BB.M_set) == 3
    
#     # First value is 0, so should be 1 (target met)
#     # Other values are non-zero, so should be 0 (target not met)
#     assert BB.M_set[0] == 1, "Value 0 should result in target met"
    
#     print("✓ combine_decryption_shares() test passed\n")


# def run_all_eval_tests():
#     """Run all eval tests."""
#     print("\n" + "="*60)
#     print("RUNNING ALL EVAL TESTS")
#     print("="*60 + "\n")
    
#     test_sub()
#     test_ord_comparison()
#     test_ct_reduction()
#     test_ct_aggregation()
#     test_epet_and_proofs()
#     test_pet_comparison()
#     test_partial_decrypt()
#     test_combine_decryption_shares()
    
#     print("="*60)
#     print("ALL EVAL TESTS PASSED! ✓")
#     print("="*60 + "\n")


# if __name__ == "__main__":
#     run_all_eval_tests()