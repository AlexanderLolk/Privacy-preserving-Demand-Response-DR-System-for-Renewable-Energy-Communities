import time
from utils.dec_proof import hash_to_bn
from utils.procedures import Procedures
from utils.ec_elgamal import ElGamal
import threshold_crypto as tc

class Eval:

    def __init__(self, dso_ek):
        self.dso_ek = dso_ek

    #####
    # Eval() outputs an evaluation and showcases which users have met the target reduction

    # enc               returns [(c1, c2), ...]     a list of tuples
    # ct_aggregation    returns (c1,c2)             a tuple
    # ct_reduction
    #   ct_b            comes from enc
    #   ct_m            comes from enc
    # epet
    # ct_sum comes from ct_aggregation and                  its a tuple
    # ct_t comes from dso target list generated by enc      its a list
    # epet runs sub, crashes because minus list and

    def sub(self, c1, c2):
        """
        Computes Enc(m1 - m2) given Enc(m1) and Enc(m2)
        Inputs are Lists [(C1, C2)]. Output is List [(C1, C2)]
        """
        # print("\nc1: \n" + str(c1))
        # print("\nc2: \n" + str(c2))

        a1, b1 = c1 # baseline from smartmeters      ||| small number
        a2, b2 = c2 # consumption from smartmeters   ||| big number
        
        return (a1 + (-a2), b1 + (-b2))

    #=============
    # Eval(BB, PBB, dk_share, agg_id, dso_ek) → (PBB, BB)
    # with threshold decryption
    #=============

    # takes dk_share and agg_id instead of full dk
    # Takes this aggregator's 'dk_share' and 'agg_id'
    def eval(self, BB, PBB, agg_share, dr_share, threshold_param):
        """
        Retrieves reports, computes individual reductions, aggregates them, 
        and initiates the threshold decryption process to verify targets
        """
        print("\nin eval")
        
        target_reduction = BB.get_target_reduction()
        baseline_BB = BB.get_sm_baseline()
        consumption_PBB = PBB.get_sm_consumption()

        # lists
        participants = BB.get_participants()
        selected = BB.get_selected_sm()

        self.el = ElGamal()
        
        agg_baselines_parts, agg_consumptions_parts = agg_share
        dr_baselines_parts, dr_consumptions_parts = dr_share

        self.for_marked_or_not_selected = []
        self.eval_results = []
        CT_red = []

        for pk_prime in participants:
            pk_prime_str = str((pk_prime.x, pk_prime.y))
            sm_baseline_t, sm_baseline_ct, sm_baseline_proof = baseline_BB[pk_prime_str]
            sm_consumption_t, sm_consumption_ct, sm_consumption_proof = consumption_PBB[pk_prime_str]

            # partial decryption of the baseline
            sm_baseline_ct_part_agg, _, _ = agg_baselines_parts[pk_prime_str]
            sm_baseline_ct_part_dr, _, _ = dr_baselines_parts[pk_prime_str]
            
            baseline = self.el._eval_threshold_decrypt((sm_baseline_ct_part_agg + sm_baseline_ct_part_dr), sm_baseline_ct)

            # partial decryption of the consumption
            sm_consumption_ct_part_agg, _, _ = agg_consumptions_parts[pk_prime_str]
            sm_consumption_ct_part_dr, _, _ = dr_consumptions_parts[pk_prime_str]

            # Would need algo like Correction to ”Improving the DGK comparison protocol” to get this to works
            # https://eprint.iacr.org/2018/1100.pdf
            # report:
            consumption = self.el._eval_threshold_decrypt((sm_consumption_ct_part_agg + sm_consumption_ct_part_dr), sm_consumption_ct)

            # step 1:ord comparison
            # TODO: ct_o is not ciphertext
            ct_o, t, ord_proof = self.ord_comparison(baseline, consumption)
            # 
            if pk_prime not in selected or ct_o < 1:
                self.for_marked_or_not_selected.append((ct_o, t, pk_prime, ord_proof))
                continue # this skip the currect loop and take the next pk_prime

            # step 2 ct reduction
            ct_red = self.ct_reduction(sm_baseline_ct, sm_consumption_ct)
            if ct_red is None:
                self.for_marked_or_not_selected.append((ct_o, t, pk_prime, ord_proof))
                continue # this skip the currect loop and take the next pk_prime
            
            self.eval_results.append((ct_o, t, pk_prime, ord_proof))
            
            # step 3 set CT_red
            CT_red.append((ct_red, t, pk_prime))

        # check if ct_red is empty
        if len(CT_red) < 1:
            return [], []
        
        # step 4: Aggregation
        ct_sum = self.ct_aggregation(CT_red)
        
        # step 5: PET comparison
        print(f"Aggregator computing new PET (ct_eq) and publishing to Board.")
        ct_eq, π_eq = self.pet_comparison(ct_sum, target_reduction)
        
        return ct_eq, π_eq
    
    def _eval(self, BB, PBB, agg_share, dr_share, ct_target_consumption_comparison_w_proof, thresh_param):
        
        ct_target_consumption_comparison, proof = ct_target_consumption_comparison_w_proof

        # STEP 6: PARTIAL DECRYPTION
        # Call partial_decrypt with agg's share
        # combine_decryption_shares(self, BB, agg_share, dr_share, ct_eq_list, thresh_params):
        M_set_final, proof_shar = self.combine_decryption_shares(agg_share, dr_share, ct_target_consumption_comparison, thresh_param)
        
        print(f"\nEvaluation complete\n")
        print(f" participants marked: {len(self.eval_results)}")
        print(f" participants not selected or did not meet baseline: {len(self.for_marked_or_not_selected)}\n")
        print(f" target comparisons {len(ct_target_consumption_comparison)}")
        print(f" Final M_set: {M_set_final}")
        print(f" eval done")

        return BB

    # (cto, t, pk′, π_ord) ← ord(ctb, ctm)
    def ord_comparison(self, baseline, consumption):
        """
        Order Comparison of two ciphertexts.
        [Intended] Should return Enc(1) if Consumption < Baseline, else Enc(0).
        Requires NIZKP.
        
        """
        # print("\nin ord_comparison")

        t = int(time.time())
        result = None
        if (consumption < baseline):
            print(f"\n\nconsumption = {consumption} is less than baseline = {baseline}\n\n")
            # result = self.el.enc(self.dso_ek[0], 1)
            result = 1
        else:
            print(f"\n\nconsumption = {consumption} have reach hights at baseline or bigger than baseline = {baseline}\n\n")
            # result = self.el.enc(self.dso_ek[0], 0)
            result = 0

        ord_proof = "ord_proof not implemented" # placeholder
        return result, t, ord_proof

    # ctred ← Reduct(ct_b, c_tm, ct_o)
    def ct_reduction(self, ct_bs, ct_cs):
        """
        (for step 2) Conditional Reduction Calculation.
        [Intended] Should compute Enc((Baseline - Consumption) * ct_o).
        Requires homomorphic multiplication to apply the condition.
        [Current] Placeholder: Returns Enc(0) (Identity point).
        Does not perform subtraction; assumes 0 reduction.
        """
        
        # baselilne - measured
        # ct_diff = sub(ct_b, ct_m)
        
        # ct_b and ct_ are lists of tuples because of enc()
        ct_diff_list = []
        for ct_b, ct_c in zip(ct_bs, ct_cs):
            ct_diff_tuple = self.sub(ct_b, ct_c)
            ct_diff_list.append(ct_diff_tuple)
        
        return ct_diff_list

    # ctsum ← Agg(ct_red)
    def ct_aggregation(self, reduc_set):
        """
        (for step 4) Homomorphic Aggregation.
        Sums all individual reductions into a single ciphertext (ct_sum).
        Uses the additive homomorphic property (for Ec).
        """

        C1_prod, C2_prod = reduc_set[0][0][0]

        for i in range(1, len(reduc_set)):
            for j in range(1, len(reduc_set[i][0])):
                C1_i, C2_i = reduc_set[i][0][j]

                C1_prod = C1_prod + C1_i
                C2_prod = C2_prod + C2_i
            
        return (C1_prod, C2_prod)

    # (cteq, πeq ) ← Pet(ctsum, ctT )
    def pet_comparison(self, ct_sum, ct_T):
        """
        (for step 5) Private Equality Test
        Iterates through targets (ct_T) to compare against ct_sum (to verify reductions).
        Calls epet for each target.
        """

        ct_eq = []
        π_eq = []

        # ct_t is a list of lists of tuples with eccpoints
        # print("pet_comparison -> ct_T: " + str(ct_T))
        for ct_T_i in ct_T:
            ct_eq_i, π_r_i = self.epet(ct_sum, ct_T_i)
            ct_eq.append(ct_eq_i)
            π_eq.append(π_r_i)

        return (ct_eq, π_eq)

    # (ct_eq_i, π_r_i) ← Epet(ct_sum, ct_T_i)
    def epet(self, ct_sum, ct_t_i):
        """
        Encrypted Private Equality Test (EPET) (page 19 in given report)
        Computes Enc(r * (Sum - Target)).
        If Sum == Target, result is Enc(0). If not, result is Enc(Random).
        Includes generation of proof 'r'.
        This uses the non-interactive zero-knowledge proof (NIZKP) proof_r

        ct_sum: tuple (c1, c2)
        ct_t_i: list of tuples [(c1, c2), ...]
        """
        # print("\nin epet")

        order = self.dso_ek[1][2]
        
        r = tc.number.random_in_range(1, order)

        ct_eq = []
            
        # Since ct_t_i is a list of typles (bit-wise encryption), we iterate through it to extract each tuple
        for (c1_t, c2_t) in ct_t_i:
            c1_sum, c2_sum = ct_sum

            c1_diff = c1_sum + (-c1_t)
            c2_diff = c2_sum + (-c2_t)

            c1_eq = int(r) * c1_diff
            c2_eq = int(r) * c2_diff

            ct_eq.append((c1_eq, c2_eq))

        # pass the lists ct_sum and ct_t_i to proof_r
        π_r_i = self.proof_r(ct_sum, ct_t_i, ct_eq, r)

        return (ct_eq, π_r_i)

        # for (c1_sum, c2_sum), (c1_t, c2_t) in zip(ct_sum, ct_t_i):
        #     c1_diff = c1_sum + (-c1_t)
        #     c2_diff = c2_sum + (-c2_t)




        # ct_diff = self.sub(ct_sum, ct_t_i)
        # (C1_diff, C2_diff) = ct_diff

        # C1_eq = int(r) * C1_diff
        # C2_eq = int(r) * C2_diff

        # # ct_eq is a tuple (not a list)
        # ct_eq = (C1_eq, C2_eq)

        # pass the lists ct_sum and ct_t_i to proof_r
        # π_r_i = self.proof_r(ct_sum, ct_t_i, ct_eq, r)

        # return (ct_eq, π_r_i)

    def proof_r(self, ct1, ct2, ct_eq, r):
        """
        NIZKP for r used in EPET.
        ct1: ct_sum (List)
        ct2: ct_target (List)
        ct_eq: Tuple (C1, C2)
        """
        # print("\nin proof_r")
        g = self.dso_ek[1][1]
        order = self.dso_ek[1][2]
        s = tc.number.random_in_range(1, order)  # nonce

        # tuples
        c1_sum, c2_sum = ct1

        A_values = []
        for (c1_t, c2_t) in ct2:
            c1_diff = c1_sum + (-c1_t)
            c2_diff = c2_sum + (-c2_t)

            A1 = int(s) * c1_diff
            A2 = int(s) * c2_diff

            A_values.append((A1, A2))

        challenge = hash_to_bn(g, self.dso_ek, ct1, ct2, ct_eq, A_values, order=order)

        response = (int(s) + int(challenge) * int(r)) % int(order)

        return (A_values, response, challenge)

    def verify_r(self, ct1, ct2, ct_eq, proof):
        """
        Verifies the NIZKP Proof for r
        """
        # print("\nin verify_r")
        g = self.dso_ek[1][1]
        order = self.dso_ek[1][2]

        A_values, response, challenge = proof

        # tuples
        c1_sum, c2_sum = ct1

        c_check = hash_to_bn(g, self.dso_ek, ct1, ct2, ct_eq, A_values, order=order)

        for (A1, A2), (c1_t, c2_t), (c1_eq, c2_eq) in zip(A_values, ct2, ct_eq):
            c1_diff = c1_sum + (-c1_t)
            c2_diff = c2_sum + (-c2_t)

            V1 = int(response) * c1_diff
            V2 = int(response) * c2_diff

            check1 = (V1 == A1 + (int(challenge) * c1_eq))
            check2 = (V2 == A2 + (int(challenge) * c2_eq))

            if not (check1 and check2):
                return False

        return int(challenge) == int(c_check)

    # Renamed from prove_epet_computation to partial_decrypt
    # ({M_share}, π_dec_share) ← PDec_Partial(ct_eq, dk_share)
    # def partial_decrypt(self, ct_eq, dk_share):
    #     """
    #     Performs partial decryption on a list of ciphertexts using
    #     this aggregator's secret key share.
    #     Returns: (M_shares_list, pi_dec_proofs)
    #     """
    #     print("\nin partial_decrypt")
    #     pro = Procedures()
        
    #     # Use the ElGamal partial_decrypt method
    #     M_shares_list = pro.ahe.partial_decrypt(ct_eq, dk_share)
        
    #     # Placeholder proofs - in production, generate actual NIZKP
    #     pi_dec_proofs = ["placeholder_proof_of_decryption_share"] * len(ct_eq)

    #     return (M_shares_list, pi_dec_proofs)

    def combine_decryption_shares(self, agg_share, dr_share, ct_eq_list, thresh_params):
        """Combine threshold decryption shares from multiple aggregators."""
        print("\nin combine_decryption_shares")
        print("Attempting to combine decryption shares...")
        # pi_dec_proofs = ["placeholder_proof_of_decryption_share"] * len(ct_eq)

        g = self.dso_ek[1][1]
        
        # Define Identity Point (0*G)
        identity_point = 0 * g
        
        M_set_final = []
        # num_aggs = len(share_lists)

        for i in range(len(ct_eq_list)):
            # Get partial decryptions for ciphertext i from all aggregators
            # partials_for_ct_i = [share_lists[agg_idx][i] for agg_idx in range(num_aggs)]
            ct_eq_i = ct_eq_list[i] # list of tuples

            agg_partial_i = agg_share[i]
            dr_partial_i = dr_share[i]
            
            combined_partial = agg_partial_i + dr_partial_i
            
            plaintext_point = self.el.threshold_decrypt(
                # partials_for_ct_i,
                combined_partial, 
                ct_eq_i,  # Pass tuple (C1, C2) directly
                thresh_params
            )
            print(f"\n check point:  x = {plaintext_point.x}, y = {plaintext_point.y} \n")
            
            if plaintext_point == identity_point:
                M_set_final.append(1)  # Target met (Diff == 0)
            else:
                M_set_final.append(0)  # Target not met (Diff != 0)
        
            # combined_partial = agg_share + dr_share
            # # using point decryption, not int
            # plaintext_point = self.el.threshold_decrypt(
            #     # partials_for_ct_i,
            #     [combined_partial], 
            #     ct_eq_list,  # Pass tuple (C1, C2) directly
            #     thresh_params
            # )

            # # Check if result is Identity (Target met) or Random (Target not met)
            
        pi_dec_proofs = ["placeholder_proof_of_decryption_share"] * len(ct_eq_list)
        return M_set_final, pi_dec_proofs


# def test_sub():
#     """Test the subtraction of two ciphertexts."""
#     print("=== Testing sub() ===")
    
#     pro = Procedures()
#     pp = pro.pub_param()
#     curve = pp[0]
#     g = pp[1]
#     order = pp[2]
    
#     # Create two simple ciphertexts
#     r1 = tc.number.random_in_range(1, order)
#     r2 = tc.number.random_in_range(1, order)
    
#     c1 = (int(r1) * g, int(r1) * g)
#     c2 = (int(r2) * g, int(r2) * g)
    
#     result = sub(c1, c2)
#     print(f"Subtraction successful: {result}")
    
#     # Verify result structure
#     assert isinstance(result, tuple) and len(result) == 2
#     print("✓ sub() test passed\n")


# def test_ord_comparison():
#     """Test order comparison placeholder."""
#     print("=== Testing ord_comparison() ===")
    
#     pro = Procedures()
#     pp = pro.pub_param()
#     g = pp[1]
#     identity = 0 * g
    
#     ct_b = (identity, identity)
#     ct_m = (identity, identity)
    
#     ct_o, proof = ord_comparison(ct_b, ct_m)
#     print(f"ord_comparison returned: ct_o={ct_o}, proof={proof}")
    
#     assert ct_o == (identity, identity)
#     print("✓ ord_comparison() test passed\n")


# def test_ct_reduction():
#     """Test ciphertext reduction placeholder."""
#     print("=== Testing ct_reduction() ===")
    
#     pro = Procedures()
#     pp = pro.pub_param()
#     g = pp[1]
#     identity = 0 * g
    
#     ct_b = (identity, identity)
#     ct_m = (identity, identity)
#     ct_o = (identity, identity)
    
#     ct_red = ct_reduction(ct_b, ct_m, ct_o)
#     print(f"ct_reduction returned: {ct_red}")
    
#     assert ct_red == (identity, identity)
#     print("✓ ct_reduction() test passed\n")


# def test_ct_aggregation():
#     """Test homomorphic aggregation of ciphertexts."""
#     print("=== Testing ct_aggregation() ===")
    
#     pro = Procedures()
#     pp = pro.pub_param()
#     g = pp[1]
#     order = pp[2]
    
#     # Create some reduction ciphertexts
#     reduc_set = []
#     for i in range(3):
#         r = tc.number.random_in_range(1, order)
#         ct_red = (int(r) * g, int(r) * g)
#         reduc_set.append((ct_red, i, f"pk_prime_{i}"))
    
#     ct_sum = ct_aggregation(reduc_set)
#     print(f"Aggregated ciphertext: {ct_sum}")
    
#     assert isinstance(ct_sum, tuple) and len(ct_sum) == 2
#     print("✓ ct_aggregation() test passed\n")


# def test_epet_and_proofs():
#     """Test EPET with proof generation and verification."""
#     print("=== Testing epet(), proof_r(), and verify_r() ===")
    
#     pro = Procedures()
#     pp = pro.pub_param()
#     curve = pp[0]
#     g = pp[1]
#     order = pp[2]
    
#     # Generate encryption key
#     sk = tc.number.random_in_range(1, order)
#     ek = int(sk) * g
    
#     # Create ct_sum (encrypted value)
#     ahe = pro.ahe
#     msg1 = 5
#     ct_sum = ahe.enc(ek, msg1)[0]  # Take first ciphertext
    
#     # Create ct_T (target - same value, should result in Enc(0))
#     msg2 = 5
#     ct_T_same = ahe.enc(ek, msg2)[0]
    
#     # Create ct_T (different value, should result in Enc(random))
#     msg3 = 7
#     ct_T_diff = ahe.enc(ek, msg3)[0]
    
#     print("\n--- Test 1: Same values (should produce Enc(0)) ---")
#     ct_eq_same, proof_same = epet(ct_sum, [ct_T_same], ek)
#     print(f"Generated ct_eq and proof")
    
#     # Verify the proof
#     is_valid_same = verify_r(ct_sum, [ct_T_same], ct_eq_same, proof_same, ek)
#     print(f"Proof verification (same values): {is_valid_same}")
#     assert is_valid_same, "Proof verification failed for same values!"
    
#     print("\n--- Test 2: Different values (should produce Enc(random)) ---")
#     ct_eq_diff, proof_diff = epet(ct_sum, [ct_T_diff], ek)
#     print(f"Generated ct_eq and proof")
    
#     # Verify the proof
#     is_valid_diff = verify_r(ct_sum, [ct_T_diff], ct_eq_diff, proof_diff, ek)
#     print(f"Proof verification (different values): {is_valid_diff}")
#     assert is_valid_diff, "Proof verification failed for different values!"
    
#     print("\n--- Test 3: Tampered proof (should fail) ---")
#     A1, A2, response, challenge = proof_diff
#     tampered_proof = (A1, A2, response + 1, challenge)  # Tamper with response
#     is_valid_tampered = verify_r(ct_sum, [ct_T_diff], ct_eq_diff, tampered_proof, ek)
#     print(f"Proof verification (tampered): {is_valid_tampered}")
#     assert not is_valid_tampered, "Tampered proof should not verify!"
    
#     print("✓ EPET and proof tests passed\n")


# def test_pet_comparison():
#     """Test PET comparison with multiple targets."""
#     print("=== Testing pet_comparison() ===")
    
#     pro = Procedures()
#     pp = pro.pub_param()
#     g = pp[1]
#     order = pp[2]
    
#     # Generate encryption key
#     sk = tc.number.random_in_range(1, order)
#     ek = int(sk) * g
    
#     # Create ct_sum
#     ahe = pro.ahe
#     msg_sum = 10
#     ct_sum = ahe.enc(ek, msg_sum)[0]
    
#     # Create multiple targets
#     ct_T = []
#     for target_val in [5, 10, 15]:
#         ct_target = ahe.enc(ek, target_val)
#         ct_T.append(ct_target)
    
#     ct_eq, π_eq = pet_comparison(ct_sum, ct_T, ek)
    
#     print(f"Generated {len(ct_eq)} equality ciphertexts")
#     print(f"Generated {len(π_eq)} proofs")
    
#     assert len(ct_eq) == 3
#     assert len(π_eq) == 3
    
#     # Verify all proofs
#     for i in range(len(ct_eq)):
#         is_valid = verify_r(ct_sum, ct_T[i], ct_eq[i], π_eq[i], ek)
#         print(f"Target {i} proof valid: {is_valid}")
#         assert is_valid, f"Proof {i} verification failed!"
    
#     print("✓ pet_comparison() test passed\n")


# def test_partial_decrypt():
#     """Test partial decryption with key shares."""
#     print("=== Testing partial_decrypt() ===")
    
#     pro = Procedures()
#     pp = pro.pub_param()
    
#     # Generate threshold keys
#     ek, key_shares, thresh_params = pro.ahe.keygen_threshold(pp)
    
#     # Encrypt some values
#     ct_eq = []
#     for val in [0, 5, 10]:
#         cts = pro.ahe.enc(ek, val)
#         ct_eq.append(cts[0])  # Take first ciphertext of each
    
#     # Get partial decryption from first key share
#     M_shares, proofs = partial_decrypt(ct_eq, key_shares[0])
    
#     print(f"Generated {len(M_shares)} partial decryptions")
#     print(f"Generated {len(proofs)} proofs")
    
#     assert len(M_shares) == 3
#     assert len(proofs) == 3
    
#     print("✓ partial_decrypt() test passed\n")


# def test_combine_decryption_shares():
#     """Test combining partial decryption shares."""
#     print("=== Testing combine_decryption_shares() ===")
    
#     # Create mock board
#     class MockBoard:
#         pass
    
#     BB = MockBoard()
    
#     pro = Procedures()
#     pp = pro.pub_param()
    
#     # Generate threshold keys (2-of-2)
#     ek, key_shares, thresh_params = pro.ahe.keygen_threshold(pp)
    
#     # Encrypt test values
#     test_values = [0, 5, 10]
#     ct_eq = []
#     for val in test_values:
#         cts = pro.ahe.enc(ek, val)
#         ct_eq.append(cts[0])
    
#     BB.ct_eq = ct_eq
    
#     # Get partial decryptions from both aggregators
#     M_shares_agg1, _ = partial_decrypt(ct_eq, key_shares[0])
#     M_shares_agg2, _ = partial_decrypt(ct_eq, key_shares[1])
    
#     BB.M_shares = {
#         "agg1": M_shares_agg1,
#         "agg2": M_shares_agg2
#     }
    
#     # Combine shares
#     combine_decryption_shares(BB, thresh_params)
    
#     print(f"Final M_set: {BB.M_set}")
#     print(f"Eval status: {BB.eval_status}")
    
#     assert hasattr(BB, "M_set")
#     assert BB.eval_status == "evaluated_complete"
#     assert len(BB.M_set) == 3
    
#     # First value is 0, so should be 1 (target met)
#     # Other values are non-zero, so should be 0 (target not met)
#     assert BB.M_set[0] == 1, "Value 0 should result in target met"
    
#     print("✓ combine_decryption_shares() test passed\n")


# def run_all_eval_tests():
#     """Run all eval tests."""
#     print("\n" + "="*60)
#     print("RUNNING ALL EVAL TESTS")
#     print("="*60 + "\n")
    
#     test_sub()
#     test_ord_comparison()
#     test_ct_reduction()
#     test_ct_aggregation()
#     test_epet_and_proofs()
#     test_pet_comparison()
#     test_partial_decrypt()
#     test_combine_decryption_shares()
    
#     print("="*60)
#     print("ALL EVAL TESTS PASSED! ✓")
#     print("="*60 + "\n")


# if __name__ == "__main__":
#     run_all_eval_tests()