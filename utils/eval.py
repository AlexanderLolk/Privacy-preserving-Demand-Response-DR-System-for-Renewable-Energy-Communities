import time
from utils.elgamal_dec_proof import hash_to_int
from utils.procedures import Procedures
from utils.ec_elgamal import ElGamal
import threshold_crypto as tc

class Eval:

    def __init__(self, dso_ek):
        self.dso_ek = dso_ek

    #####
    # Eval() outputs an evaluation and showcases which users have met the target reduction

    # enc               returns [(c1, c2), ...]     a list of tuples
    # ct_aggregation    returns (c1,c2)             a tuple
    # ct_reduction
    #   ct_b            comes from enc
    #   ct_m            comes from enc
    # epet
    # ct_sum comes from ct_aggregation and                  its a tuple
    # ct_t comes from dso target list generated by enc      its a list
    # epet runs sub, crashes because minus list and

    def sub(self, c1, c2):
        """
        Computes Enc(m1 - m2) given Enc(m1) and Enc(m2)
        Inputs are Lists [(C1, C2)]. Output is List [(C1, C2)]
        """
        # print("\nc1: \n" + str(c1))
        # print("\nc2: \n" + str(c2))

        a1, b1 = c1 # baseline
        a2, b2 = c2 # consumption
        
        # a1 and b1 should be a higher encrypted value, so it should not decrypt to negative
        return (a1 + (-a2), b1 + (-b2))

    #=============
    # Eval(BB, PBB, dk_share, agg_id, dso_ek) → (PBB, BB)
    # with threshold decryption
    #=============

    # takes dk_share and agg_id instead of full dk
    # Takes this aggregator's 'dk_share' and 'agg_id'
    def eval(self, BB, PBB, agg_share, dr_share, threshold_param):
        """
        Retrieves reports, computes individual reductions, aggregates them, 
        and initiates the threshold decryption process to verify targets
        """
        print("\nin eval")
        
        target_reduction = BB.get_target_reduction()
        baseline_BB = BB.get_sm_baseline()
        consumption_PBB = PBB.get_sm_consumption()

        # lists
        participants = BB.get_participants()
        selected = BB.get_selected_sm()

        self.el = ElGamal()
        
        agg_baselines_parts, agg_consumptions_parts = agg_share
        dr_baselines_parts, dr_consumptions_parts = dr_share

        self.for_marked_or_not_selected = []
        self.eval_results = []
        CT_red = []

        for pk_prime in participants:
            pk_prime_str = str((pk_prime.x, pk_prime.y))
            sm_baseline_t, sm_baseline_ct, sm_baseline_proof = baseline_BB[pk_prime_str]
            sm_consumption_t, sm_consumption_ct, sm_consumption_proof = consumption_PBB[pk_prime_str]

            # partial decryption of the baseline
            sm_baseline_ct_part_agg, _, _ = agg_baselines_parts[pk_prime_str]
            sm_baseline_ct_part_dr, _, _ = dr_baselines_parts[pk_prime_str]
            
            baseline = self.el._eval_threshold_decrypt((sm_baseline_ct_part_agg + sm_baseline_ct_part_dr), sm_baseline_ct)

            # partial decryption of the consumption
            sm_consumption_ct_part_agg, _, _ = agg_consumptions_parts[pk_prime_str]
            sm_consumption_ct_part_dr, _, _ = dr_consumptions_parts[pk_prime_str]

            # Would need algo like Correction to ”Improving the DGK comparison protocol” to get this to works
            # https://eprint.iacr.org/2018/1100.pdf
            # report:
            consumption = self.el._eval_threshold_decrypt((sm_consumption_ct_part_agg + sm_consumption_ct_part_dr), sm_consumption_ct)

            # step 1:ord comparison
            # TODO: ct_o is not ciphertext
            ct_o, t, ord_proof = self.ord_comparison(baseline, consumption)
            # 
            if pk_prime not in selected or ct_o < 1:
                self.for_marked_or_not_selected.append((ct_o, t, pk_prime, ord_proof))
                continue # this skip the currect loop and take the next pk_prime

            # step 2 ct reduction
            ct_red = self.ct_reduction(sm_baseline_ct, sm_consumption_ct)
            if ct_red is None:
                self.for_marked_or_not_selected.append((ct_o, t, pk_prime, ord_proof))
                continue # this skip the currect loop and take the next pk_prime
            
            self.eval_results.append((ct_o, t, pk_prime, ord_proof))
            
            # step 3 set CT_red
            CT_red.append((ct_red, t, pk_prime))

        # check if ct_red is empty
        if len(CT_red) < 1:
            return [], []
        
        # step 4: Aggregation
        ct_sum = self.ct_aggregation(CT_red)
        
        # step 5: PET comparison
        print(f"Aggregator computing new PET (ct_eq) and publishing to Board.")
        ct_eq, π_eq = self.pet_comparison(ct_sum, target_reduction)
        
        return ct_eq, π_eq
    
    def _eval(self, BB, PBB, agg_share, dr_share, ct_target_consumption_comparison_w_proof, thresh_param):
        
        ct_target_consumption_comparison, proof = ct_target_consumption_comparison_w_proof

        # STEP 6: PARTIAL DECRYPTION
        # Call partial_decrypt with agg's share
        # combine_decryption_shares(self, BB, agg_share, dr_share, ct_eq_list, thresh_params):
        M_set_final, proof_shar = self.combine_decryption_shares(agg_share, dr_share, ct_target_consumption_comparison, thresh_param)
        
        print(f"\nEvaluation complete\n")
        print(f" participants marked: {len(self.eval_results)}")
        print(f" participants not selected or did not meet baseline: {len(self.for_marked_or_not_selected)}\n")
        print(f" target comparisons {len(ct_target_consumption_comparison)}")
        print(f" Final M_set: {M_set_final}")
        print(f" eval done")

        return BB

    # (cto, t, pk′, π_ord) ← ord(ctb, ctm)
    def ord_comparison(self, baseline, consumption):
        """
        Order Comparison of two ciphertexts.
        [Intended] Should return Enc(1) if Consumption < Baseline, else Enc(0).
        Requires NIZKP.
        
        """
        # print("\nin ord_comparison")

        t = int(time.time())
        result = None
        if (consumption < baseline):
            print(f"\n\nconsumption = {consumption} is less than baseline = {baseline}\n\n")
            # result = self.el.enc(self.dso_ek[0], 1)
            result = 1
        else:
            print(f"\n\nconsumption = {consumption} have reach hights at baseline or bigger than baseline = {baseline}\n\n")
            # result = self.el.enc(self.dso_ek[0], 0)
            result = 0

        ord_proof = "ord_proof not implemented" # placeholder
        return result, t, ord_proof

    # ctred ← Reduct(ct_b, c_tm, ct_o)
    def ct_reduction(self, ct_bs, ct_cs):
        """
        (for step 2) Conditional Reduction Calculation.
        [Intended] Should compute Enc((Baseline - Consumption) * ct_o).
        Requires homomorphic multiplication to apply the condition.
        [Current] Placeholder: Returns Enc(0) (Identity point).
        Does not perform subtraction; assumes 0 reduction.
        """
        
        # baselilne - measured
        # ct_diff = sub(ct_b, ct_m)
        
        # ct_b and ct_ are lists of tuples because of enc()
        ct_diff_list = []
        for ct_b, ct_c in zip(ct_bs, ct_cs):
            ct_diff_tuple = self.sub(ct_b, ct_c)
            ct_diff_list.append(ct_diff_tuple)
        
        return ct_diff_list

    # ctsum ← Agg(ct_red)
    def ct_aggregation(self, reduc_set):
        """
        (for step 4) Homomorphic Aggregation.
        Sums all individual reductions into a single ciphertext (ct_sum).
        Uses the additive homomorphic property (for Ec).
        """

        C1_prod, C2_prod = reduc_set[0][0][0]

        for i in range(1, len(reduc_set)):
            for j in range(1, len(reduc_set[i][0])):
                C1_i, C2_i = reduc_set[i][0][j]

                C1_prod = C1_prod + C1_i
                C2_prod = C2_prod + C2_i
            
        return (C1_prod, C2_prod)

    # (cteq, πeq ) ← Pet(ctsum, ctT )
    def pet_comparison(self, ct_sum, ct_T):
        """
        (for step 5) Private Equality Test
        Iterates through targets (ct_T) to compare against ct_sum (to verify reductions).
        Calls epet for each target.
        """

        ct_eq = []
        π_eq = []

        # ct_t is a list of lists of tuples with eccpoints
        # print("pet_comparison -> ct_T: " + str(ct_T))
        for ct_T_i in ct_T:
            ct_eq_i, π_r_i = self.epet(ct_sum, ct_T_i)
            ct_eq.append(ct_eq_i)
            π_eq.append(π_r_i)

        return (ct_eq, π_eq)

    # (ct_eq_i, π_r_i) ← Epet(ct_sum, ct_T_i)
    def epet(self, ct_sum, ct_t_i):
        """
        Encrypted Private Equality Test (EPET) (page 19 in given report)
        Computes Enc(r * (Sum - Target)).
        If Sum == Target, result is Enc(0). If not, result is Enc(Random).
        Includes generation of proof 'r'.
        This uses the non-interactive zero-knowledge proof (NIZKP) proof_r

        ct_sum: tuple (c1, c2)
        ct_t_i: list of tuples [(c1, c2), ...]
        """
        # print("\nin epet")

        order = self.dso_ek[1][2]
        
        r = tc.number.random_in_range(1, order)

        ct_eq = []
            
        # Since ct_t_i is a list of typles (bit-wise encryption), we iterate through it to extract each tuple
        for (c1_t, c2_t) in ct_t_i:
            c1_sum, c2_sum = ct_sum

            c1_diff = c1_sum + (-c1_t)
            c2_diff = c2_sum + (-c2_t)

            c1_eq = int(r) * c1_diff
            c2_eq = int(r) * c2_diff

            ct_eq.append((c1_eq, c2_eq))

        # pass the lists ct_sum and ct_t_i to proof_r
        π_r_i = self.proof_r(ct_sum, ct_t_i, ct_eq, r)

        return (ct_eq, π_r_i)

    def proof_r(self, ct1, ct2, ct_eq, r):
        """
        NIZKP for r used in EPET.
        ct1: ct_sum (List)
        ct2: ct_target (List)
        ct_eq: Tuple (C1, C2)
        """
        # print("\nin proof_r")
        g = self.dso_ek[1][1]
        order = self.dso_ek[1][2]
        s = tc.number.random_in_range(1, order)  # nonce

        # tuples
        c1_sum, c2_sum = ct1

        A_values = []
        for (c1_t, c2_t) in ct2:
            c1_diff = c1_sum + (-c1_t)
            c2_diff = c2_sum + (-c2_t)
            A_values.append((c1_diff, c2_diff))

            # A1 = int(s) * c1_diff
            # A2 = int(s) * c2_diff

            # A_values.append((A1, A2))

        challenge = hash_to_int(g, self.dso_ek, ct1, ct2, ct_eq, A_values, order=order)

        response = (int(s) + int(challenge) * int(r)) % int(order)

        return (A_values, response, challenge)

    def verify_r(self, ct1, ct2, ct_eq, proof):
        """
        Verifies the NIZKP Proof for r
        """
        # print("\nin verify_r")
        g = self.dso_ek[1][1]
        order = self.dso_ek[1][2]

        A_values, response, challenge = proof

        # tuples
        c1_sum, c2_sum = ct1

        c_check = hash_to_int(g, self.dso_ek, ct1, ct2, ct_eq, A_values, order=order)

        for (A1, A2), (c1_t, c2_t), (c1_eq, c2_eq) in zip(A_values, ct2, ct_eq):
            c1_diff = c1_sum + (-c1_t)
            c2_diff = c2_sum + (-c2_t)

            V1 = int(response) * c1_diff
            V2 = int(response) * c2_diff

            check1 = (V1 == A1 + (int(challenge) * c1_eq))
            check2 = (V2 == A2 + (int(challenge) * c2_eq))

            if not (check1 and check2):
                return False

        return int(challenge) == int(c_check)

    # Renamed from prove_epet_computation to partial_decrypt
    # ({M_share}, π_dec_share) ← PDec_Partial(ct_eq, dk_share)
    # def partial_decrypt(self, ct_eq, dk_share):
    #     """
    #     Performs partial decryption on a list of ciphertexts using
    #     this aggregator's secret key share.
    #     Returns: (M_shares_list, pi_dec_proofs)
    #     """
    #     print("\nin partial_decrypt")
    #     pro = Procedures()
        
    #     # Use the ElGamal partial_decrypt method
    #     M_shares_list = pro.ahe.partial_decrypt(ct_eq, dk_share)
        
    #     # Placeholder proofs - in production, generate actual NIZKP
    #     pi_dec_proofs = ["placeholder_proof_of_decryption_share"] * len(ct_eq)

    #     return (M_shares_list, pi_dec_proofs)

    def combine_decryption_shares(self, agg_share, dr_share, ct_eq_list, thresh_params):
        """Combine threshold decryption shares from multiple aggregators."""
        print("\nin combine_decryption_shares")
        print("Attempting to combine decryption shares...")
        # pi_dec_proofs = ["placeholder_proof_of_decryption_share"] * len(ct_eq)

        g = self.dso_ek[1][1]
        
        # Define Identity Point (0*G)
        identity_point = 0 * g
        
        M_set_final = []
        # num_aggs = len(share_lists)

        for i in range(len(ct_eq_list)):
            # Get partial decryptions for ciphertext i from all aggregators
            # partials_for_ct_i = [share_lists[agg_idx][i] for agg_idx in range(num_aggs)]
            ct_eq_i = ct_eq_list[i] # list of tuples

            agg_partial_i = agg_share[i]
            dr_partial_i = dr_share[i]
            
            combined_partial = agg_partial_i + dr_partial_i
            
            plaintext_point = self.el.threshold_decrypt(
                # partials_for_ct_i,
                combined_partial, 
                ct_eq_i,  # Pass tuple (C1, C2) directly
                thresh_params
            )
            print(f"\n check point:  x = {plaintext_point.x}, y = {plaintext_point.y} \n")
            
            if plaintext_point == identity_point:
                M_set_final.append(1)  # Target met (Diff == 0)
            else:
                M_set_final.append(0)  # Target not met (Diff != 0)
        
            # combined_partial = agg_share + dr_share
            # # using point decryption, not int
            # plaintext_point = self.el.threshold_decrypt(
            #     # partials_for_ct_i,
            #     [combined_partial], 
            #     ct_eq_list,  # Pass tuple (C1, C2) directly
            #     thresh_params
            # )

            # # Check if result is Identity (Target met) or Random (Target not met)
            
        pi_dec_proofs = ["placeholder_proof_of_decryption_share"] * len(ct_eq_list)
        return M_set_final, pi_dec_proofs
